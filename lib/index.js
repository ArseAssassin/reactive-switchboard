// Generated by CoffeeScript 1.9.2
(function() {
  var _, board, kefir, signal, snd,
    slice = [].slice;

  kefir = require('kefir');

  _ = require('lodash');

  snd = function(a, b) {
    return b;
  };

  kefir.emitter = function() {
    var emitter, stream;
    emitter = null;
    stream = kefir.stream(function(_emitter) {
      return emitter = _emitter;
    });
    stream.emit = function(x) {
      if (emitter != null) {
        emitter.emit(x);
      }
      return this;
    };
    stream.emit.emit = stream.emit;
    stream.error = function(x) {
      if (emitter != null) {
        emitter.error(x);
      }
      return this;
    };
    stream.emitEvent = function(x) {
      if (emitter != null) {
        emitter.emitEvent(x);
      }
      return this;
    };
    stream.end = function(x) {
      return emitter != null ? emitter.end() : void 0;
    };
    return stream.setName('emitter');
  };

  kefir.Observable.prototype.doAction = function(f) {
    return this.map(function(it) {
      f(it);
      return it;
    });
  };

  kefir.Observable.prototype.not = function() {
    return this.map(function(it) {
      return !it;
    });
  };

  kefir.Observable.prototype.holdLatestWhile = function(obs) {
    var emitter, isBlocked, setIsFree, tryFlush, value;
    emitter = null;
    isBlocked = true;
    value = null;
    tryFlush = function() {
      if (!isBlocked && value !== null && emitter) {
        emitter.emit(value);
        return value = null;
      }
    };
    setIsFree = function(it) {
      isBlocked = it;
      return tryFlush();
    };
    obs.onValue(setIsFree);
    return this.withHandler(function(_emitter, event) {
      emitter = _emitter;
      if (event.type === 'end') {
        obs.offValue(setIsFree);
        return emitter.end();
      } else if (event.type === 'value') {
        value = event.value;
        return tryFlush();
      }
    }).setName('holdLatestWhile');
  };

  kefir.Observable.prototype.rescue = function(f) {
    return this.withHandler(function(emitter, event) {
      if (event.type === 'end') {
        return emitter.end();
      } else if (event.type === 'value') {
        return emitter.emit(event.value);
      } else if (event.type === 'error') {
        return emitter.emit(f(event.value));
      }
    });
  };

  kefir.Observable.prototype.cancel = function() {
    return this.map(function(e) {
      e.preventDefault();
      return e;
    });
  };

  kefir.Observable.prototype.set = function(value) {
    return this.map(function() {
      return value;
    });
  };

  kefir.Observable.prototype.extract = function() {};

  kefir.Observable.prototype.extract = function() {
    return this.map(function(e) {
      return e.target.value;
    });
  };

  kefir.Observable.prototype.wire = function(self, fn) {
    if (fn) {
      this.state = self.state;
      this.props = self.props;
      this.slot = self.slot;
      this.board = self.board;
      return fn.call(this);
    } else {
      return self.call(this);
    }
  };

  kefir.Observable.prototype.to = function() {
    var i, len, slot, slots;
    slots = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (i = 0, len = slots.length; i < len; i++) {
      slot = slots[i];
      if (!slot.emit) {
        throw new Error("Expected slot to be an emitter, received " + (slot != null ? slot.toString() : void 0));
      }
    }
    return this.onValue(function(it) {
      return slots.forEach(function(slot) {
        return slot.emit(it);
      });
    });
  };

  signal = {
    create: function() {
      var reducers, value;
      value = arguments[0], reducers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      reducers = [].concat(reducers).reduce(function(r, nextValue) {
        if (nextValue.call) {
          r[r.length - 1].push(nextValue);
          return r;
        } else {
          return r.concat([[nextValue]]);
        }
      }, []);
      return kefir.merge([kefir.constant(value)].concat(reducers.map(function(arg) {
        var f, stream;
        stream = arg[0], f = arg[1];
        f || (f = function(oldValue, newValue) {
          return newValue;
        });
        return stream.map(function(newValue) {
          return f(value, newValue);
        });
      }))).doAction(function(newValue) {
        return value = newValue;
      }).toProperty();
    }
  };

  board = {
    create: function(fn) {
      var o, slots;
      slots = {};
      o = {
        wire: function(fn) {
          var emitter;
          emitter = kefir.emitter();
          emitter.slot = o.slot;
          fn.call(emitter);
          return emitter;
        },
        signal: function() {
          var reducers, value;
          value = arguments[0], reducers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return signal.create.apply(signal, [value].concat(slice.call(reducers)));
        },
        slot: function(name) {
          return slots[name] || (slots[name] = kefir.emitter());
        }
      };
      if (fn != null) {
        fn.call(o);
      }
      return o;
    }
  };

  module.exports = {
    create: function(fn) {
      board = board.create(fn);
      return {
        board: board,
        mixin: {
          getInitialState: function() {
            var blocked, fn1, initialState, k, ref, self, stream, streams;
            this.board = board;
            this._alive = kefir.emitter();
            this._rerender = kefir.emitter();
            this._receiveProps = kefir.emitter();
            this._receiveState = kefir.emitter();
            this._wires = [];
            this.isAlive = this._alive.scan(snd, true);
            this.dead = this.isAlive.filter(function(it) {
              return it === false;
            });
            this._propStream = this._receiveProps.scan(snd, this.props);
            this.slots = {};
            self = this;
            streams = [];
            initialState = {};
            this.wiring = true;
            ref = typeof this.wireState === "function" ? this.wireState() : void 0;
            fn1 = function(k, stream) {
              stream.take(1).onValue(function(it) {
                return initialState[k] = it;
              });
              return streams.push(stream.skip(1).map(function(it) {
                return [k, it];
              }));
            };
            for (k in ref) {
              stream = ref[k];
              this.wiring = false;
              fn1(k, stream);
            }
            if (streams.length) {
              this._blockers = kefir.emitter();
              blocked = this._blockers.scan(snd, true).skipDuplicates();
              this.updates = kefir.merge(streams).takeUntilBy(this.dead).skipDuplicates(_.isEqual).scan(function(state, arg) {
                var name, obj, value;
                name = arg[0], value = arg[1];
                return _.assign({}, state, (
                  obj = {},
                  obj["" + name] = value,
                  obj
                ));
              }, {}).skipDuplicates(_.isEqual).wire(function() {
                this.to(self._receiveState);
                return this.holdLatestWhile(blocked).onValue(function(state) {
                  return self.setState(state);
                });
              });
            }
            return initialState;
          },
          propsProperty: function() {
            var names;
            names = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            if (names.length === 1) {
              return this._propStream.map(function(it) {
                return it[names[0]];
              }).skipDuplicates();
            } else {
              return this._propStream.map(function(it) {
                return names.map(function(name) {
                  return it[name];
                });
              }).skipDuplicates(_.isEqual);
            }
          },
          stateProperty: function(name) {
            return this._receiveState.map(function(it) {
              return it[name];
            }).filter(function(it) {
              return it;
            }).skipDuplicates();
          },
          componentWillReceiveProps: function(nextProps) {
            return this._receiveProps.emit(nextProps);
          },
          signal: function() {
            var reducers, value;
            value = arguments[0], reducers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return signal.create.apply(signal, [value].concat(slice.call(reducers))).takeUntilBy(this.dead);
          },
          wire: function(fn) {
            var wire;
            if (!fn) {
              throw new Error("wire takes function as argument, received " + (fn != null ? fn.toString() : void 0));
            }
            this._wires.push(wire = kefir.emitter());
            wire.wire(this, fn);
            return wire.emit;
          },
          slot: function(name) {
            var base;
            return (base = this.slots)[name] || (base[name] = kefir.emitter());
          },
          componentWillUnmount: function() {
            var k, ref, ref1, results, v;
            this._alive.emit(false);
            if ((ref = this._blockers) != null) {
              ref.end();
            }
            this._alive.end();
            this._rerender.end();
            this._receiveProps.end();
            ref1 = this.slots;
            results = [];
            for (k in ref1) {
              v = ref1[k];
              results.push(v.end());
            }
            return results;
          },
          componentDidMount: function() {
            var ref;
            return (ref = this._blockers) != null ? ref.emit(false) : void 0;
          },
          clearSignals: function() {
            var results;
            results = [];
            while (this._wires.length) {
              results.push(this._wires.pop().end());
            }
            return results;
          },
          componentWillUpdate: function() {
            var ref;
            if ((ref = this._blockers) != null) {
              ref.emit(true);
            }
            this._rerender.emit(true);
            return this.clearSignals();
          },
          componentDidUpdate: function() {
            var ref;
            return (ref = this._blockers) != null ? ref.emit(false) : void 0;
          }
        }
      };
    }
  };

}).call(this);
